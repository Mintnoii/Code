"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcss = _interopRequireDefault(require("postcss"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pluginName = 'postcss-url-parser';

function getArg(nodes) {
  return nodes.length !== 0 && nodes[0].type === 'string' ? nodes[0].value : _postcssValueParser.default.stringify(nodes);
}

function walkUrls(parsed, callback) {
  parsed.walk(node => {
    if (node.type !== 'function' || node.value.toLowerCase() !== 'url') {
      return;
    }
    /* eslint-disable */


    node.before = '';
    node.after = '';
    /* eslint-enable */

    callback(node, getArg(node.nodes)); // Do not traverse inside url
    // eslint-disable-next-line consistent-return

    return false;
  });
}

function walkDeclsWithUrl(css, result, filter) {
  const items = [];
  css.walkDecls(decl => {
    if (!/url\(/i.test(decl.value)) {
      return;
    }

    const parsed = (0, _postcssValueParser.default)(decl.value);
    const urls = [];
    walkUrls(parsed, (node, url) => {
      if (url.trim().replace(/\\[\r\n]/g, '').length === 0) {
        result.warn(`Unable to find uri in '${decl.toString()}'`, {
          node: decl
        });
        return;
      }

      if (filter && !filter(url)) {
        return;
      }

      urls.push(url);
    });

    if (urls.length === 0) {
      return;
    }

    items.push({
      decl,
      parsed,
      urls
    });
  });
  return items;
}

function flatten(array) {
  return array.reduce((acc, d) => [...acc, ...d], []);
}

function uniq(array) {
  return array.reduce((acc, d) => acc.indexOf(d) === -1 ? [...acc, d] : acc, []);
}

var _default = _postcss.default.plugin(pluginName, (options = {}) => function process(css, result) {
  const traversed = walkDeclsWithUrl(css, result, options.filter);
  const paths = uniq(flatten(traversed.map(item => item.urls)));

  if (paths.length === 0) {
    return;
  }

  const urls = {};
  paths.forEach((path, index) => {
    const placeholder = `___CSS_LOADER_URL___${index}___`;
    urls[path] = placeholder;
    result.messages.push({
      pluginName,
      type: 'url',
      item: {
        url: path,
        placeholder
      }
    });
  });
  traversed.forEach(item => {
    walkUrls(item.parsed, (node, url) => {
      const value = urls[url];

      if (!value) {
        return;
      } // eslint-disable-next-line no-param-reassign


      node.nodes = [{
        type: 'word',
        value
      }];
    }); // eslint-disable-next-line no-param-reassign

    item.decl.value = item.parsed.toString();
  });
});

exports.default = _default;