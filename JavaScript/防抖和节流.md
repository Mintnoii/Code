## 防抖

```javascript
// 防抖 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
const debounce = (fn,wait = 500) => {
  let timer = null
  return function(...args){
    if (timer) clearTimeout(timer)
    timer = setTimeout(()=>{
      fn.apply(this, args)
    },wait)
  }
}
function say(){
  console.log('hi')
}
$('#testInput').on('input',debounce(say,2000))
```

这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。

> - 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用`延迟执行`的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。
> - 例如用户点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用`立即执行`的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。

立即执行版本：

```javascript

```



## 节流

```javascript
// 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
function throttle(fn){
  let isend = true
  // 判断该方法是否已经结束上次执行
  
  return function(){
    if(!isend) return
    isend = false
    setTimeout(()=>{
      fn.apply(this, arguments)
      isend = true
    },2000)
  }
}
function say(){
  console.log('hi')
}
$('#testInput').on('input',throttle(say))
```

