```javascript
var foo = {n:1}
(function(foo){
    console.log(foo.n)
    foo.n = 3
    var foo = {n:2}
    console.log(foo.n)
})(foo)
console.log(foo.n)
```

题目描述：以上代码，在浏览器中运行的结果是？

1. 1 2 3
2.  undefined 2 1
3. 报错
4. 1 2 1

> **正确答案：A**
>
> 第一步：进行预编译，var全局变量foo、匿名函数 function、var局部变量foo 
>
> 第二步：代码自上而下、自左向右执行计算： 
>
> 对全局变量foo进行赋值foo={n:1}；注意：此值为对象，属于引用类型； 
>
> 匿名函数传入参数foo={n:1}自执行； 
>
> console.log(foo);打出数字1； 
>
> 由于存在foo局部变量，那么对foo变量进行赋值foo={n:3}，同时更改了引用类型的参数值，全局foo变量被重新赋值foo={n:3}； 
>
> 对局部变量foo进行重新赋值foo={n:2}; 
>
> console.log(foo);打出数字2； 
>
> 全局变量foo={n:3},因此，console.log(foo);打出数字3；



**(不定项选择题)**语句 var arr=[ a, b, c, d];执行后，数组 arr中每项都是一个整数，下面得到其中最大整数语句正确的是哪几项？

A. Math.max(arr)

B. Math. max( arr[0], arr[1], arr[2], arr[3])

C. Math.max.call(Math, arr[0], arr[1], arr[2], arr[3])

D. Math.max.apply(Math,arr)

> **正确答案：BCD**
>
> A选项错误因为函数 Math. max( x);的参数是 Number类型，可以是小数，整数，正数，负数或者是0.如果不是上面所述类型就会返回 NaN
>
> B选项同理，正确
>
> C选项Function. call() 第二个参数可以传入任意多个参数, 正确 
>
> D选项 Function. apply()第二个参数以数组形式传递, 正确



```javascript
var x = new Boolean(false)
if (x) { 
  alert('hi')
} 
var y = Boolean(0)
if (y) { 
  alert('hello')
}
```

的输出结果是什么？

A. hi

B. hi hello

C. hello

D. 不显示

> **正确答案：A**
>
> 此题考查的是 JS的类型转换
>
> 题目第一部分， if( x) 这里期望 x是一个布尔类型的原始值，而 x 是一个对象，任何对象转为布尔值，都为得到 true。**（切记！在 JS中，只有0，-0， NaN，""， null， undefined这六个值转布尔值时，结果为 false）**。
>
> 题目的第二部分，一定要注意 y= Boolean(0)，而不是 y= new Boolean(0)。这两个有很大区别，用 new调用构造函数会新建一个布尔对象，此处没有加 new，进行的是显示类型转换，正如上述第一条所说，0转换布尔，结果为 false，所以此时 y的值就是 false。如果加了 new，那么 y就是一个 Boolean类型的对象，执行 if( y)时，对象转布尔，始终是 true，所以结果会与不加 new的时候相反。



```javascript
console.log(([])?true:false)
console.log(([] == false?true:false))
console.log(({} == false)?true:false)
```

得到的结果分别是什么？

A. false true true 

B. true true true

C. true false true

D. true true false

> **正确答案：D**
>
> 下面是题目的类型转换结果：
>
> Boolean([]); //true 
>
> Number([]); //0 
>
> Number({}); // 
>
> NaN Number(false); //0 
>
> 因此：
>
> console.log(([])?true:fasle)	// => console.log((true)?true:false)
>
> console.log([]==false?true:false) 	// => console.log(0==0?true:false)
>
> console.log(({}==false)?true:false) 	// => console.log((NaN==0)?true:false)



null和undefined的区别：

> 目前，null和undefined基本是同义的，只有一些细微的差别。
>
> **null表示"没有对象"，即该处不应该有值。**典型用法是：
>
> > （1） 作为函数的参数，表示该函数的参数不是对象。
> >
> > （2） 作为对象原型链的终点。
> >
> > ```javascript
> > Object.getPrototypeOf(Object.prototype)
> > // null
> > ```
>
> **undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。**典型用法是：
>
> > （1）变量被声明了，但没有赋值时，就等于undefined。
> >
> > （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
> >
> > （3）对象没有赋值的属性，该属性的值为undefined。
> >
> > （4）函数没有返回值时，默认返回undefined。
> >
> > ```javascript
> > var i;
> > i // undefined
> > 
> > function f(x){console.log(x)}
> > f() // undefined
> > 
> > var  o = new Object();
> > o.p // undefined
> > 
> > var x = f();
> > x // undefined
> > ```



https://github.com/Wscats/articles/issues/85

```js
function Foo() {
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//请写出以下输出结果：
Foo.getName();  // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```

这道题的经典之处在于它综合考察了面试者的JavaScript的综合能力，包含了变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识

**第一问**

先看此题的上半部分做了什么，首先定义了一个叫 Foo 的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数表达式创建了一个getName的函数，最后再通过函数声明定义了一个叫getName函数。

第一问的Foo.getName自然是访问Foo函数上存储的静态属性，答案自然是2，这里就不需要解释太多的，一般来说第一问对于稍微懂JS基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解

```js
function User(name) {
	var name = name; //私有属性
	this.name = name; //公有属性
	function getName() { //私有方法
		return name;
	}
}
User.prototype.getName = function() { //公有方法
	return this.name;
}
User.name = 'Wscats'; //静态属性
User.getName = function() { //静态方法
	return this.name;
}
var Wscat = new User('Wscats'); //实例化
```

注意下面这几点：

- 调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的
- 静态方法和静态属性就是我们无需实例化就可以调用
- 而对象的私有方法和属性,外部是不可以访问的

**第二问**

第二问，直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以这里应该直接把关注点放在4和5上，跟1 2 3都没什么关系。当然后来我问了我的几个同事他们大多数回答了5。此处其实有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。
我们来看看为什么，可参考(1)关于Javascript的函数声明和函数表达式 (2)关于JavaScript的变量提升
在Javascript中，定义函数有两种类型

函数声明
```js
// 函数声明
function wscat(type) {
	return type === "wscat";
}
```

函数表达式
```js
// 函数表达式
var oaoafly = function(type) {
	return type === "oaoafly";
}
```

先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为getName的函数
```js
getName() //oaoafly
var getName = function() {
	console.log('wscat')
}
getName() //wscat
function getName() {
	console.log('oaoafly')
}
getName() //wscat
```
上面的代码看起来很类似，感觉也没什么太大差别。但实际上，Javascript函数上的一个“陷阱”就体现在Javascript两种类型的函数定义上。

- JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。
- 而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用
```js
var getName //变量被提升，此时为undefined

getName() //oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了
var getName = function() {
	console.log('wscat')
} //函数表达式此时才开始覆盖函数声明的定义
getName() //wscat
function getName() {
	console.log('oaoafly')
}
getName() //wscat 这里就执行了函数表达式的值
```

所以可以分解为这两个简单的问题来看清楚区别的本质

```js
var getName;
console.log(getName) //undefined
getName() //Uncaught TypeError: getName is not a function
var getName = function() {
	console.log('wscat')
}            
var getName;
console.log(getName) //function getName() {console.log('oaoafly')}
getName() //oaoafly
function getName() {
	console.log('oaoafly')
}
```
这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命“的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。
当然我们给一个总结：Javascript中函数声明和函数表达式是存在区别的，函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。
所以第二问的答案就是4，5的函数声明被4的函数表达式覆盖了

**第三问**

`Foo().getName();` 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。
Foo函数的第一句`getName = function () { alert (1); };`是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为`function(){alert(1)}`。
此处实际上是将外层作用域内的getName函数修改了。

> 注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。

之后Foo函数的返回值是this，而JS的this问题已经有非常多的文章介绍，这里不再多说。
简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。
遂Foo函数返回的是window对象，相当于执行window.getName()，而window中的getName已经被修改为alert(1)，所以最终会输出1
此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题
我们可以利用下面代码来回顾下这两个知识点
```js
var name = "Wscats"; //全局变量
window.name = "Wscats"; //全局变量
function getName() {
	name = "Oaoafly"; //去掉var变成了全局变量
	var privateName = "Stacsw";
	return function() {
		console.log(this); //window
		return privateName
	}
}
var getPrivate = getName("Hello"); //当然传参是局部变量，但函数里面我没有接受这个参数
console.log(name) //Oaoafly
console.log(getPrivate()) //Stacsw
```

因为JS没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真的是第一公民呀~
而关于this，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象
所以第三问中实际上就是window在调用**Foo()**函数，所以this的指向是window
```js
window.Foo().getName();
//->window.getName();
```

**第四问**
直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的那个getName函数



typeof 的问题?

foreach 与 map 的区别？

懒加载的原理、图片优化？

首屏100张图片，加载比较慢 如何优化？

浏览器的请求并发限制？

webpack代理转发 target changOrigin

数组去重的几种方法，越多越好

隐藏页面元素的方法，6-7种？

react 的 key 的作用，为什么不用index作为key?

