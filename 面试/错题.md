```javascript
var foo = {n:1}
(function(foo){
    console.log(foo.n)
    foo.n = 3
    var foo = {n:2}
    console.log(foo.n)
})(foo)
console.log(foo.n)
```

题目描述：以上代码，在浏览器中运行的结果是？

1. 1 2 3
2.  undefined 2 1
3. 报错
4. 1 2 1

> **正确答案：A**
>
> 第一步：进行预编译，var全局变量foo、匿名函数 function、var局部变量foo 
>
> 第二步：代码自上而下、自左向右执行计算： 
>
> 对全局变量foo进行赋值foo={n:1}；注意：此值为对象，属于引用类型； 
>
> 匿名函数传入参数foo={n:1}自执行； 
>
> console.log(foo);打出数字1； 
>
> 由于存在foo局部变量，那么对foo变量进行赋值foo={n:3}，同时更改了引用类型的参数值，全局foo变量被重新赋值foo={n:3}； 
>
> 对局部变量foo进行重新赋值foo={n:2}; 
>
> console.log(foo);打出数字2； 
>
> 全局变量foo={n:3},因此，console.log(foo);打出数字3；



**(不定项选择题)**语句 var arr=[ a, b, c, d];执行后，数组 arr中每项都是一个整数，下面得到其中最大整数语句正确的是哪几项？

A. Math.max(arr)

B. Math. max( arr[0], arr[1], arr[2], arr[3])

C. Math.max.call(Math, arr[0], arr[1], arr[2], arr[3])

D. Math.max.apply(Math,arr)

> **正确答案：BCD**
>
> A选项错误因为函数 Math. max( x);的参数是 Number类型，可以是小数，整数，正数，负数或者是0.如果不是上面所述类型就会返回 NaN
>
> B选项同理，正确
>
> C选项Function. call() 第二个参数可以传入任意多个参数, 正确 
>
> D选项 Function. apply()第二个参数以数组形式传递, 正确



```javascript
var x = new Boolean(false)
if (x) { 
  alert('hi')
} 
var y = Boolean(0)
if (y) { 
  alert('hello')
}
```

的输出结果是什么？

A. hi

B. hi hello

C. hello

D. 不显示

> **正确答案：A**
>
> 此题考查的是 JS的类型转换
>
> 题目第一部分， if( x) 这里期望 x是一个布尔类型的原始值，而 x 是一个对象，任何对象转为布尔值，都为得到 true。**（切记！在 JS中，只有0，-0， NaN，""， null， undefined这六个值转布尔值时，结果为 false）**。
>
> 题目的第二部分，一定要注意 y= Boolean(0)，而不是 y= new Boolean(0)。这两个有很大区别，用 new调用构造函数会新建一个布尔对象，此处没有加 new，进行的是显示类型转换，正如上述第一条所说，0转换布尔，结果为 false，所以此时 y的值就是 false。如果加了 new，那么 y就是一个 Boolean类型的对象，执行 if( y)时，对象转布尔，始终是 true，所以结果会与不加 new的时候相反。



```javascript
console.log(([])?true:false)
console.log(([] == false?true:false))
console.log(({} == false)?true:false)
```

得到的结果分别是什么？

A. false true true 

B. true true true

C. true false true

D. true true false

> **正确答案：D**
>
> 下面是题目的类型转换结果：
>
> Boolean([]); //true 
>
> Number([]); //0 
>
> Number({}); // 
>
> NaN Number(false); //0 
>
> 因此：
>
> console.log(([])?true:fasle)	// => console.log((true)?true:false)
>
> console.log([]==false?true:false) 	// => console.log(0==0?true:false)
>
> console.log(({}==false)?true:false) 	// => console.log((NaN==0)?true:false)



null和undefined的区别：

> 目前，null和undefined基本是同义的，只有一些细微的差别。
>
> **null表示"没有对象"，即该处不应该有值。**典型用法是：
>
> > （1） 作为函数的参数，表示该函数的参数不是对象。
> >
> > （2） 作为对象原型链的终点。
> >
> > ```javascript
> > Object.getPrototypeOf(Object.prototype)
> > // null
> > ```
>
> **undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。**典型用法是：
>
> > （1）变量被声明了，但没有赋值时，就等于undefined。
> >
> > （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
> >
> > （3）对象没有赋值的属性，该属性的值为undefined。
> >
> > （4）函数没有返回值时，默认返回undefined。
> >
> > ```javascript
> > var i;
> > i // undefined
> > 
> > function f(x){console.log(x)}
> > f() // undefined
> > 
> > var  o = new Object();
> > o.p // undefined
> > 
> > var x = f();
> > x // undefined
> > ```